\documentclass[a4paper,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{float}
\usepackage{hyperref}

\newtheorem{prop}{Proposition}
\newtheorem{preuve}{Preuve}

% Notation cohérente avec le sujet
\newcommand{\nvertices}{n}
\newcommand{\nedges}{m}
\newcommand{\nqueries}{\ell}
\newcommand{\noise}{c}
\newcommand{\lambdaf}[2]{\lambda_{#1}(#2)}

\begin{document}

\begin{titlepage}
\centering
\vspace*{1.5cm}
{\LARGE \textbf{INF421 — Projet de programmation}}\\[0.5cm]
{\Huge \textbf{Most Pleasant Itineraries}}\\[1cm]
\rule{0.7\textwidth}{1pt}\\[0.5cm]
{\large Version finale — Novembre 2025}\\[1.5cm]

\begin{flushleft}
\textbf{Encadrant :} Patrick Loiseau (\texttt{patrick.loiseau@inria.fr})\\[0.3cm]
\textbf{Auteurs :} Gurvan Ronel NKOUATHIO KEMNHOU, Demartino KUETE TSAYO\\[0.3cm]
\textbf{Promotion :} X2024\\[0.3cm]
\textbf{Année :} 2025--2026
\end{flushleft}

\vfill
\end{titlepage}

\tableofcontents
\newpage

%=============================================================================
\section{Introduction et énoncé du problème}
%=============================================================================

On considère une ville (par exemple Paris) modélisée par un \textbf{graphe connexe non orienté} $G = (V, E)$. À chaque arête $e \in E$ est associé un \textbf{niveau de bruit} $\noise_e \geq 0$ (entier). Pour une paire de sommets $(u,v)$, un \emph{itinéraire le plus agréable} entre $u$ et $v$ est un chemin $u$--$v$ dans $G$ qui \textbf{minimise le maximum} des niveaux de bruit des arêtes du chemin. La valeur renvoyée pour la requête $(u,v)$ est ce maximum (sur un tel chemin optimal) ; par convention, le maximum sur un chemin vide est $0$.

Formellement, pour tout chemin $P$ reliant $u$ à $v$ dans $G$, on note $\max_{e \in P} \noise_e$ le maximum des bruits sur $P$. La réponse à la requête $(u,v)$ est
\[
\lambdaf{G}{u,v} = \min_{\substack{P \text{ chemin } u \to v \text{ dans } G}} \max_{e \in P} \noise_e.
\]
On dispose d’un ensemble de $\nqueries$ requêtes (paires de sommets). Pour chaque requête, il faut calculer cette valeur. On notera $\nvertices = |V|$ et $\nedges = |E|$.

Ce rapport décrit trois implémentations progressivement plus efficaces : \texttt{itineraries\_v1} (requête en $O(\nvertices)$), \texttt{itineraries\_v2} (prétraitement $O(\nvertices \log \nvertices)$, requête en $O(\log \nvertices)$), et \texttt{itineraries\_v3} (prétraitement linéaire en $\nvertices$ et $|P|$, requête en temps constant en moyenne lorsque l’ensemble des requêtes $P$ est connu à l’avance).

%=============================================================================
\section{Task 1 : Lien entre itinéraire le plus agréable et arbre couvrant minimal}
%=============================================================================

\begin{prop}
Soit $T$ un arbre couvrant minimal (MST) de $G$. Pour toute paire $(u,v) \in V \times V$, la réponse à la requête $(u,v)$ dans $G$ est égale à la réponse à la même requête dans $T$, i.e.\
\[
\lambdaf{G}{u,v} = \lambdaf{T}{u,v},
\]
où $\lambdaf{T}{u,v} = \max_{e \in P_T(u,v)} \noise_e$ et $P_T(u,v)$ désigne l’unique chemin entre $u$ et $v$ dans $T$.
\end{prop}

\begin{preuve}
\paragraph{(i) Inégalité $\lambdaf{G}{u,v} \leq \lambdaf{T}{u,v}$.}
Comme $T \subseteq G$, le chemin $P_T(u,v)$ est un chemin $u$--$v$ admissible dans $G$. Donc
\[
\lambdaf{G}{u,v} \leq \max_{e \in P_T(u,v)} \noise_e = \lambdaf{T}{u,v}.
\]

\paragraph{(ii) Inégalité $\lambdaf{G}{u,v} \geq \lambdaf{T}{u,v}$ (par l’absurde).}
Supposons qu’il existe $(u,v)$ tel que $\lambdaf{G}{u,v} < \lambdaf{T}{u,v}$. Il existe alors un chemin $P$ dans $G$ reliant $u$ à $v$ avec $\max_{e \in P} \noise_e < \lambdaf{T}{u,v}$. Soit $e^* \in P_T(u,v)$ une arête telle que $\noise_{e^*} = \lambdaf{T}{u,v}$. Le chemin $P$ ne contient pas $e^*$ (sinon $\max_{e \in P} \noise_e \geq \noise_{e^*}$).

\paragraph{Existence d’un cycle contenant $e^*$.}
Considérons le graphe $T \cup P$. Le chemin $P_T(u,v)$ relie $u$ à $v$ dans $T$ et contient $e^*$. Le chemin $P$ relie aussi $u$ à $v$ et ne contient pas $e^*$. Ainsi $T \cup P$ contient deux chemins $u$--$v$ distincts ; leur union contient donc un cycle, et ce cycle contient $e^*$. En ajoutant les arêtes de $P$ à $T$ une à une, la première arête $f \in P$ dont l’ajout crée un cycle forme un cycle $C$ contenant $e^*$.

\paragraph{Échange et contradiction.}
On a $\noise_f \leq \max_{e \in P} \noise_e < \noise_{e^*}$. Soit $T' = T \cup \{f\} \setminus \{e^*\}$. Comme $e^*$ appartient au cycle $C$ créé par l’ajout de $f$, retirer $e^*$ casse le cycle et préserve la connexité : $T'$ est encore un arbre couvrant. Son poids vérifie $w(T') = w(T) - \noise_{e^*} + \noise_f < w(T)$, ce qui contredit la minimalité de $T$.

\paragraph{Conclusion.}
$\lambdaf{G}{u,v} = \lambdaf{T}{u,v}$ pour toute paire $(u,v)$.
\end{preuve}

%=============================================================================
\section{Task 2 : \texttt{itineraries\_v1} — Requête naïve dans l’arbre couvrant minimal}
%=============================================================================

\subsection{Objectif}
On suppose qu’un arbre couvrant minimal $T$ de $G$ a été calculé en prétraitement (par exemple avec l’algorithme de Prim). On souhaite répondre à chaque requête $(u,v)$ en calculant $\lambdaf{T}{u,v}$ par un parcours dans $T$, avec une complexité temporelle $O(\nvertices)$ par requête.

\subsection{Principe}
On effectue un \textbf{parcours en profondeur (DFS)} depuis $u$ en direction de $v$, en maintenant le maximum des poids rencontrés le long du chemin courant. Dès que l’on atteint $v$, on renvoie ce maximum.

\subsubsection{Éviter de remonter}
Le graphe est représenté par une liste d’adjacence : chaque sommet a la liste de tous ses voisins. Lorsqu’on est en un sommet \texttt{current}, les voisins incluent le sommet par lequel on est arrivé (le « parent » sur le chemin). Pour simuler un parcours uniquement vers l’avant, on transmet à chaque appel récursif le sommet \texttt{from} d’où l’on vient et on \textbf{ignore} le voisin égal à \texttt{from}.

\subsubsection{Cas particuliers}
\begin{itemize}[leftmargin=*]
  \item Si $u = v$, le chemin est vide ; on renvoie $0$ (convention du sujet).
\end{itemize}

\subsection{Pseudo-code}
\begin{algorithm}[H]
\caption{Maximum sur le chemin entre $u$ et $v$ dans un arbre (\texttt{itineraries\_v1})}
\begin{algorithmic}[1]
\Function{itineraries\_v1}{$T$, $u$, $v$}
  \If{$u = v$}
    \State \Return $0$
  \EndIf
  \State \Return \Call{dfs\_path}{$T$, $u$, $v$, $-1$, $-\infty$}
\EndFunction
\State
\Function{dfs\_path}{$T$, $\mathtt{current}$, $\mathtt{target}$, $\mathtt{from}$, $\mathtt{path\_max}$}
  \If{$\mathtt{current} = \mathtt{target}$}
    \State \Return $\mathtt{path\_max}$
  \EndIf
  \For{chaque $(\mathtt{voisin}, \mathtt{poids})$ dans $T.\mathtt{voisins}(\mathtt{current})$}
    \If{$\mathtt{voisin} = \mathtt{from}$}
      \State \textbf{continue}
    \EndIf
    \State $\mathtt{nouveau\_max} \gets \max(\mathtt{path\_max}, \mathtt{poids})$
    \State $\mathtt{resultat} \gets$ \Call{dfs\_path}{$T$, $\mathtt{voisin}$, $\mathtt{target}$, $\mathtt{current}$, $\mathtt{nouveau\_max}$}
    \If{$\mathtt{resultat} \neq \mathtt{null}$}
      \State \Return $\mathtt{resultat}$
    \EndIf
  \EndFor
  \State \Return $\mathtt{null}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Terminaison}
À chaque appel récursif, on se déplace de \texttt{current} vers un voisin $\neq$ \texttt{from}, donc on ajoute une arête au chemin. Comme $T$ est un arbre, il n’y a pas de cycle : on ne repasse pas par un sommet déjà visité sur le chemin courant. Le nombre de sommets étant fini et $T$ connexe, on atteint $v$ en un nombre fini d’étapes. L’algorithme termine.

\subsection{Preuve de correction}
\begin{prop}
Pour tout couple $(u,v)$ de sommets de $T$ (arbre couvrant minimal de $G$), \texttt{itineraries\_v1}$(T,u,v)$ renvoie le maximum des poids des arêtes sur l’unique chemin reliant $u$ et $v$ dans $T$.
\end{prop}
\begin{preuve}
D’après la Task 1, exécuter la requête sur $G$ équivaut à l’exécuter sur $T$. On montre par récurrence sur la structure de l’arbre que \texttt{dfs\_path}$(T,u,v,-1,-\infty)$ explore exactement l’unique chemin de $u$ à $v$.
\begin{itemize}[leftmargin=*]
  \item \textbf{Cas de base :} $u = v$. On renvoie $\mathtt{path\_max} = 0$ (chemin vide).
  \item \textbf{Étape :} $u \neq v$. Il existe une unique arête $\{u,u_1\}$ sur le chemin de $u$ à $v$. Pour tout autre voisin $w$ de $u$, $v$ n’est pas dans la composante de $w$ après suppression de $u$. Donc \texttt{dfs\_path} ne trouve $v$ que via le voisin $u_1$. En ignorant \texttt{from}, on n’explore pas deux fois la même arête. Le chemin suivi est bien l’unique chemin $u \to u_1 \to \cdots \to v$, et $\mathtt{path\_max}$ vaut au final le maximum des poids des arêtes de ce chemin.
\end{itemize}
\end{preuve}

\subsection{Complexité}
Temps : $O(\nvertices)$ par requête (chaque sommet du chemin visité au plus une fois ; chaque arête de $T$ vue $O(1)$ fois). Espace : $O(\nvertices)$ (pile récursive).

%=============================================================================
\section{Task 3 : \texttt{itineraries\_v2} — Requête en $O(\log n)$ (LCA et binary lifting)}
%=============================================================================

\subsection{Objectif}
Pour l’arbre $T$ (MST de $G$), on souhaite :
\begin{enumerate}[leftmargin=*]
  \item Répondre aux requêtes \textbf{LCA}$(u,v)$ en temps $O(\log \nvertices)$.
  \item Calculer le maximum des poids sur le chemin d’un sommet $u$ vers un ancêtre $a$ en temps $O(\log \nvertices)$.
  \item En déduire \texttt{itineraries\_v2}$(T,u,v)$ en $O(\log \nvertices)$ par requête après prétraitement.
\end{enumerate}
On enracine $T$ au \textbf{centre} (milieu d’un diamètre) et on remplit le tableau \textbf{parent} (et \textbf{depth}).

\subsection{Idée générale}
\begin{enumerate}[leftmargin=*]
  \item Partir d’un sommet quelconque $s$, faire un \textbf{BFS} pour trouver un sommet $u$ \textbf{le plus éloigné} de $s$.
  \item Repartir de $u$, refaire un BFS pour trouver un sommet $v$ le plus éloigné de $u$. Le chemin $u \leftrightarrow v$ est un \textbf{diamètre} de $T$.
  \item Le \textbf{centre} est le \textbf{milieu} de ce diamètre (sommet central ou l’une des deux extrémités de l’arête centrale).
  \item On enracine $T$ en ce centre et on remplit \texttt{parent} et \texttt{depth} par un DFS depuis la racine.
  \item Pour le LCA et le max sur un chemin, on utilise le \textbf{binary lifting} (voir plus bas).
\end{enumerate}
\paragraph{Pourquoi deux BFS suffisent.}
En partant d’un sommet arbitraire, un sommet à \textbf{distance maximale} est toujours une \textbf{extrémité d’un diamètre}. En repartant de cette extrémité, le sommet le plus éloigné donne l’autre extrémité. Propriété classique des arbres.

\subsection{Sommet le plus éloigné et chemin (BFS)}
On utilise un BFS depuis \texttt{start} ; on garde les distances et les « parents BFS » pour reconstruire le chemin.

\begin{algorithm}[H]
\caption{Farthest et chemin (BFS)}
\begin{algorithmic}[1]
\Function{FarthestEtChemin}{$T$, $\mathtt{start}$}
  \State $\nvertices \gets |V(T)|$
  \State \texttt{dist}[0..$\nvertices$-1] $\gets -1$, \texttt{parent\_bfs}[0..$\nvertices$-1] $\gets -1$
  \State \texttt{file} $\gets$ file contenant \texttt{start}
  \State \texttt{dist[start]} $\gets 0$
  \While{\texttt{file} non vide}
    \State $u \gets$ défiler(\texttt{file})
    \For{chaque voisin $v$ de $u$}
      \If{\texttt{dist[v]} $= -1$}
        \State \texttt{dist[v]} $\gets$ \texttt{dist[u]} $+ 1$
        \State \texttt{parent\_bfs[v]} $\gets u$
        \State enfiler(\texttt{file}, $v$)
      \EndIf
    \EndFor
  \EndWhile
  \State \texttt{farthest} $\gets$ un sommet $v$ tel que \texttt{dist[v]} soit maximal
  \State \texttt{path} $\gets$ liste vide, $v \gets \mathtt{farthest}$
  \While{$v \neq -1$}
    \State ajouter $v$ au \textbf{début} de \texttt{path}
    \State $v \gets \texttt{parent\_bfs[v]}$
  \EndWhile
  \State \Return $(\mathtt{farthest}, \mathtt{path})$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Diamètre et centre}
\begin{algorithm}[H]
\caption{Diamètre et centre}
\begin{algorithmic}[1]
\Function{DiametreEtCentre}{$T$}
  \State $s \gets$ un sommet quelconque (ex.\ $0$)
  \State $(u, \mathtt{path\_su}) \gets$ \Call{FarthestEtChemin}{$T$, $s$}
  \State $(v, \mathtt{path\_diam}) \gets$ \Call{FarthestEtChemin}{$T$, $u$}
  \Comment{\texttt{path\_diam} = diamètre}
  \State $L \gets |\mathtt{path\_diam}| - 1$
  \If{$L$ pair ($L = 2k$)}
    \State \texttt{centre} $\gets \mathtt{path\_diam}[k]$
  \Else
    \State \texttt{centre} $\gets \mathtt{path\_diam}[(L+1)/2]$
  \EndIf
  \State \Return $(\mathtt{path\_diam}, L, \mathtt{centre})$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Tableau parent et profondeur}
On remplit \texttt{parent} et \texttt{depth} par un DFS depuis la racine \texttt{centre}.

\begin{algorithm}[H]
\caption{Remplir parent et profondeur}
\begin{algorithmic}[1]
\Function{RemplirParentEtProfondeur}{$T$, $\mathtt{racine}$}
  \State \texttt{parent}[0..$\nvertices$-1] $\gets -1$, \texttt{depth}[0..$\nvertices$-1] $\gets -1$
  \State \texttt{depth[racine]} $\gets 0$
  \State \Call{DFSParent}{$T$, $\mathtt{racine}$, $-1$, \texttt{parent}, \texttt{depth}}
\EndFunction
\State
\Function{DFSParent}{$T$, $\mathtt{current}$, $\mathtt{from}$, \texttt{parent}, \texttt{depth}}
  \For{chaque voisin $v$ de \texttt{current}}
    \If{$v \neq \mathtt{from}$}
      \State \texttt{parent[v]} $\gets \mathtt{current}$, \texttt{depth[v]} $\gets \mathtt{depth[current]} + 1$
      \State \Call{DFSParent}{$T$, $v$, $\mathtt{current}$, \texttt{parent}, \texttt{depth}}
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{LCA par remontée des ancêtres (référence)}
On part de $u$ et $v$, on remonte vers la racine en stockant les ancêtres dans deux piles (généalogie de $u$ et de $v$). Puis on dépile tant que les sommets au sommet des deux piles sont égaux ; le dernier sommet commun dépilé est le LCA. Complexité $O(h)$ où $h$ est la hauteur (au pire $O(\nvertices)$). Pour garantir $O(\log \nvertices)$ dans tous les cas, on utilise le \textbf{binary lifting} ci-dessous.

\begin{algorithm}[H]
\caption{LCA par remontée des ancêtres (complexité $O(h)$)}
\begin{algorithmic}[1]
\Function{LCARemontée}{$u$, $v$}
  \State \texttt{pile\_u} $\gets$ pile vide, \texttt{pile\_v} $\gets$ pile vide
  \State $w \gets u$
  \While{$w \neq -1$}
    \State empiler $w$ dans \texttt{pile\_u}
    \State $w \gets \mathtt{parent}[w]$
  \EndWhile
  \State $w \gets v$
  \While{$w \neq -1$}
    \State empiler $w$ dans \texttt{pile\_v}
    \State $w \gets \mathtt{parent}[w]$
  \EndWhile
  \State $lca \gets -1$
  \While{\texttt{pile\_u} et \texttt{pile\_v} non vides \textbf{et} sommet(\texttt{pile\_u}) $=$ sommet(\texttt{pile\_v})}
    \State $lca \gets$ dépiler(\texttt{pile\_u})
    \State dépiler(\texttt{pile\_v})
  \EndWhile
  \State \Return $lca$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Binary lifting}
Pour chaque sommet $v$ et chaque $k$ (puissance de 2), on précalcule $\mathtt{up}[v][k]$ (le $2^k$-ième ancêtre de $v$) et $\mathtt{max\_up}[v][k]$ (max des poids sur le chemin $v \to \mathtt{up}[v][k]$). Avec $\mathtt{mid} = \mathtt{up}[v][k-1]$ :
\[
\mathtt{up}[v][k] = \mathtt{up}[\mathtt{mid}][k-1], \quad
\mathtt{max\_up}[v][k] = \max\bigl(\mathtt{max\_up}[v][k-1], \mathtt{max\_up}[\mathtt{mid}][k-1]\bigr).
\]

\begin{algorithm}[H]
\caption{Précalcul binary lifting}
\begin{algorithmic}[1]
\State $K \gets \lceil \log_2 \nvertices \rceil$
\For{$v \in V$}
  \State $\mathtt{up}[v][0] \gets \mathtt{parent}[v]$, $\mathtt{max\_up}[v][0] \gets \mathtt{parent\_edge\_weight}[v]$
\EndFor
\For{$k = 1$ \textbf{to} $K$}
  \For{$v \in V$}
    \State $\mathtt{mid} \gets \mathtt{up}[v][k-1]$
    \If{$\mathtt{mid} \neq -1$}
      \State $\mathtt{up}[v][k] \gets \mathtt{up}[\mathtt{mid}][k-1]$
      \State $\mathtt{max\_up}[v][k] \gets \max(\mathtt{max\_up}[v][k-1], \mathtt{max\_up}[\mathtt{mid}][k-1])$
    \Else
      \State $\mathtt{up}[v][k] \gets -1$
    \EndIf
  \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{LCA par binary lifting (implémentation réelle)}
\begin{enumerate}[leftmargin=*]
  \item Mettre $u$ et $v$ à la même profondeur : remonter le nœud le plus profond de $d = \mathtt{depth}[u] - \mathtt{depth}[v]$ pas en décomposant $d$ en puissances de 2 (sauts $\mathtt{up}[\cdot][k]$).
  \item Si $u = v$, retourner $u$.
  \item Sinon, remonter $u$ et $v$ ensemble par paliers $2^k$ : pour $k$ du plus grand au plus petit, si $\mathtt{up}[u][k] \neq \mathtt{up}[v][k]$, alors $u \gets \mathtt{up}[u][k]$, $v \gets \mathtt{up}[v][k]$. À la fin, le LCA est $\mathtt{up}[u][0]$.
\end{enumerate}
Complexité : $O(\log \nvertices)$ par requête.

\begin{algorithm}[H]
\caption{LCA$(u,v)$ par binary lifting}
\begin{algorithmic}[1]
\Function{LCA}{$u$, $v$}
  \If{$\mathtt{depth}[u] < \mathtt{depth}[v]$} \State \Call{Swap}{$u$, $v$} \EndIf
  \State $d \gets \mathtt{depth}[u] - \mathtt{depth}[v]$
  \For{$k = K$ \textbf{downto} $0$}
    \If{$d \geq 2^k$} \State $u \gets \mathtt{up}[u][k]$, $d \gets d - 2^k$ \EndIf
  \EndFor
  \If{$u = v$} \State \Return $u$ \EndIf
  \For{$k = K$ \textbf{downto} $0$}
    \If{$\mathtt{up}[u][k] \neq \mathtt{up}[v][k]$}
      \State $u \gets \mathtt{up}[u][k]$, $v \gets \mathtt{up}[v][k]$
    \EndIf
  \EndFor
  \State \Return $\mathtt{up}[u][0]$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Max sur le chemin vers un ancêtre en $O(\log n)$}
On veut $\mathrm{max\_on\_path\_to\_ancestor}(u,a)$ = maximum des poids sur le chemin de $u$ vers l’ancêtre $a$. Soit $d = \mathtt{depth}[u] - \mathtt{depth}[a]$ ; on décompose $d$ en puissances de 2 et on utilise $\mathtt{max\_up}$ lors des sauts.

\begin{algorithm}[H]
\caption{max\_on\_path\_to\_ancestor$(u,a)$}
\begin{algorithmic}[1]
\Function{MaxOnPathToAncestor}{$u$, $a$}
  \If{$u = a$} \State \Return $0$ \EndIf
  \State $d \gets \mathtt{depth}[u] - \mathtt{depth}[a]$
  \If{$d \leq 0$} \State \Return \texttt{nullopt} \EndIf
  \State $\mathtt{result} \gets -\infty$, $\mathtt{current} \gets u$
  \For{$k = K$ \textbf{downto} $0$}
    \If{$d \geq 2^k$}
      \State $\mathtt{result} \gets \max(\mathtt{result}, \mathtt{max\_up}[\mathtt{current}][k])$
      \State $\mathtt{current} \gets \mathtt{up}[\mathtt{current}][k]$, $d \gets d - 2^k$
    \EndIf
  \EndFor
  \If{$\mathtt{current} \neq a$} \State \Return \texttt{nullopt} \EndIf
  \State \Return $\mathtt{result}$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Preuve de correction (max vers ancêtre)}
Pour tout $v$ et $k$, $\mathtt{up}[v][k]$ est le $2^k$-ième ancêtre de $v$ (récurrence : $k=0$ par définition, $k \geq 1$ avec $\mathtt{mid} = \mathtt{up}[v][k-1]$). De même $\mathtt{max\_up}[v][k]$ est le max sur le chemin $v \to \mathtt{up}[v][k]$. La décomposition binaire de $d$ utilise au plus $\lceil \log_2 \nvertices \rceil$ itérations ; après la boucle, \texttt{current} $= a$ et \texttt{result} est le max sur le chemin $u \to a$.

\subsubsection{Complexité (max vers ancêtre)}
Une requête \texttt{MaxOnPathToAncestor} : $O(\log \nvertices)$. Précalcul des tables : $O(\nvertices \log \nvertices)$.

\subsection{Réponse \texttt{itineraries\_v2}$(u,v)$}
Le chemin $u$--$v$ dans $T$ est l’union des chemins $u \to L$ et $L \to v$ avec $L = \mathrm{LCA}(u,v)$. Donc le maximum des poids sur le chemin $u$--$v$ est $\max(m_u, m_v)$ où $m_u = \mathrm{MaxOnPathToAncestor}(u,L)$ et $m_v = \mathrm{MaxOnPathToAncestor}(v,L)$.

\begin{algorithm}[H]
\caption{\texttt{itineraries\_v2}$(u,v)$}
\begin{algorithmic}[1]
\Function{itineraries\_v2}{$u$, $v$}
  \State $L \gets \Call{LCA}{u, v}$
  \If{$L = \mathtt{null}$} \State \Return \texttt{nullopt} \EndIf
  \State $m_u \gets \Call{MaxOnPathToAncestor}{u, L}$
  \State $m_v \gets \Call{MaxOnPathToAncestor}{v, L}$
  \State \Return $\max(m_u, m_v)$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Complexité globale (Task 3)}
\begin{itemize}[leftmargin=*]
  \item \textbf{FarthestEtChemin} : un BFS, $O(\nvertices)$.
  \item \textbf{DiametreEtCentre} : deux BFS, $O(\nvertices)$.
  \item \textbf{RemplirParentEtProfondeur} : un DFS, $O(\nvertices)$.
  \item \textbf{Précalcul binary lifting} : $O(\nvertices \log \nvertices)$ temps et espace.
  \item \textbf{LCA} (une requête) : $O(\log \nvertices)$.
  \item \textbf{MaxOnPathToAncestor} (une requête) : $O(\log \nvertices)$.
  \item \textbf{Prétraitement total} : $O(\nvertices \log \nvertices)$. \textbf{Requête} : $O(\log \nvertices)$.
\end{itemize}

%=============================================================================
\section{Task 4 : \texttt{itineraries\_v3} — Algorithme de Tarjan (requête en $O(1)$ en moyenne)}
%=============================================================================

\subsection{Cadre}
L’ensemble des requêtes $P$ est \textbf{connu à l’avance}. On utilise l’algorithme de Tarjan pour calculer tous les LCA des paires de $P$ en un seul passage DFS, puis on calcule pour chaque paire $(u,v)$ le maximum sur le chemin (via $\mathrm{max\_on\_path\_to\_ancestor}$) et on stocke le résultat dans une table de hachage. Ensuite, chaque requête est répondue par un accès à la table en $O(1)$ en moyenne.

\subsection{Algorithme de Tarjan pour le LCA (sujet)}
Le pseudo-code suivant détermine le LCA de chaque paire de $P$ ; la fonction \texttt{TarjanLCA} est appelée initialement sur la racine $r$ de $T$. Chaque nœud a un pointeur \texttt{parent} ; \texttt{MakeSet}, \texttt{Find}, \texttt{Union} sont les opérations de la structure Union-Find.

\begin{algorithm}[H]
\caption{Tarjan — plus bas ancêtre commun (hors-ligne)}
\begin{algorithmic}[1]
\Function{TarjanLCA}{$u$}
  \State \Call{MakeSet}{$u$}
  \State $u.\mathtt{parent} \gets u$
  \For{chaque enfant $v$ de $u$ dans $T$}
    \State \Call{TarjanLCA}{$v$}
    \State \Call{Union}{$u$, $v$}
    \State $\Call{Find}{u}.\mathtt{parent} \gets u$
  \EndFor
  \State $u.\mathtt{visited} \gets \mathtt{true}$
  \For{chaque $v$ tel que $(u, v) \in P$}
    \If{$v.\mathtt{visited}$}
      \State réponse pour la requête $(u, v) \gets \Call{Find}{v}.\mathtt{parent}$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Prétraitement \texttt{itineraries\_v3}}
\begin{enumerate}[nosep]
  \item Calculer le centre, parent, binary lifting (comme en v2).
  \item Exécuter Tarjan pour obtenir tous les LCA des paires de $P$ en $O(\nvertices + |P|)$.
  \item Pour chaque $(u,v) \in P$, soit $L = \mathrm{LCA}(u,v)$ ; calculer $m = \max(\mathrm{max\_path}(u \to L), \mathrm{max\_path}(v \to L))$ et stocker $m$ dans une table indexée par $\{u,v\}$.
\end{enumerate}

\subsection{Terminaison (Tarjan)}
Chaque nœud $u$ est visité exactement une fois par le DFS. Pour chaque $u$, on effectue un nombre fini d’opérations (MakeSet, appels récursifs, Union, boucle sur les requêtes). Les opérations Union-Find terminent (avec compression de chemin). Donc l’algorithme termine.

\subsection{Preuve de correction (Tarjan)}
À tout moment, les ensembles Union-Find forment une partition des nœuds déjà visités ; pour chaque ensemble, le \texttt{parent} du représentant est un ancêtre commun de tous les nœuds de l’ensemble. Quand on traite la requête $(u,v)$ au nœud $u$ avec $v$ déjà visité, $v$ n’est pas dans le sous-arbre de $u$ ; le représentant de la classe de $v$ a pour \texttt{parent} le nœud auquel cette classe a été rattachée en dernier, qui est le plus bas ancêtre de $v$ ayant fini le traitement de son sous-arbre et qui est ancêtre de $u$. C’est bien le LCA de $u$ et $v$.

\subsection{Complexité (Task 4)}
\begin{itemize}[nosep]
  \item \textbf{Prétraitement} : Tarjan en $O(\nvertices + |P|)$ ; pour chaque paire, deux appels à $\mathrm{max\_on\_path\_to\_ancestor}$ en $O(\log \nvertices)$, donc au total $O(\nvertices + |P| \log \nvertices)$ pour remplir la table. Le cœur Tarjan est linéaire en $\nvertices$ et $|P|$.
  \item \textbf{Requête} : accès à la table en $O(1)$ en moyenne.
\end{itemize}

%=============================================================================
\section{Format des tests et des sorties}
%=============================================================================

\subsection{Entrée (\texttt{itineraries.in})}
\begin{itemize}[nosep]
  \item Ligne 1 : deux entiers $\nvertices$ et $\nedges$ (nombre de sommets et d’arêtes de $G$).
  \item Lignes 2 à $\nedges+1$ : trois entiers $u$, $v$, $\noise$ avec $u,v \in \{1,\ldots,\nvertices\}$ et $0 \leq \noise < 2^{31}$, indiquant une arête $(u,v)$ de niveau de bruit $\noise$.
  \item Ligne $\nedges+2$ : un entier $\nqueries$ (nombre de requêtes).
  \item Lignes suivantes : $\nqueries$ paires d’entiers $u,v \in \{1,\ldots,\nvertices\}$ (une requête par ligne).
\end{itemize}
Contraintes du sujet : $\nvertices \leq 200\,000$, $\nedges \leq 300\,000$, $\nqueries \leq 500\,000$.

\subsection{Sortie (\texttt{itineraries.out})}
Le fichier contient $\nqueries$ lignes : la $i$-ème ligne est un entier donnant la réponse à la $i$-ème requête (maximum du niveau de bruit sur un itinéraire le plus agréable entre les deux sommets ; 0 pour un chemin vide).

%=============================================================================
\section{Rapport des temps d’exécution}
%=============================================================================

Les temps d’exécution ont été mesurés pour les trois algorithmes \texttt{itineraries\_v1}, \texttt{itineraries\_v2} et \texttt{itineraries\_v3} sur les 10 tests fournis. Pour chaque test et chaque algorithme, on indique le temps total (prétraitement + requêtes) en millisecondes, ou \textbf{N/A} si l’algorithme n’a pas fourni de sortie dans les 30 secondes.

Les résultats détaillés (temps par requête, résumés) sont stockés dans le dossier \texttt{Runtimes/} du projet : pour chaque fichier \texttt{itineraries.$i$.in}, le dossier \texttt{Runtimes/itineraries.$i$/} contient \texttt{v1.txt}, \texttt{v2.txt}, \texttt{v3.txt} (une ligne par requête : temps en ms ou N/A si $> 30$ s pour cette requête) et \texttt{summary.txt} (résumé des temps totaux et tailles).

\begin{center}
\begin{tabular}{@{}lccc@{}}
\toprule
Test & \texttt{itineraries\_v1} & \texttt{itineraries\_v2} & \texttt{itineraries\_v3} \\
\midrule
itineraries.0 & (voir Runtimes/) & (voir Runtimes/) & (voir Runtimes/) \\
itineraries.1 & \ldots & \ldots & \ldots \\
\ldots & \ldots & \ldots & \ldots \\
itineraries.9 & \ldots ou N/A & \ldots ou N/A & \ldots ou N/A \\
\bottomrule
\end{tabular}
\end{center}

\noindent\textit{Remarque :} Remplir le tableau avec les valeurs des fichiers \texttt{Runtimes/itineraries.$i$/summary.txt} ou exécuter le script \texttt{scripts/run\_itineraries\_with\_output.sh} pour régénérer toutes les sorties et les runtimes.

%=============================================================================
\section{Résumé des structures utilisées (implémentation C++)}
%=============================================================================

\begin{center}
\begin{tabular}{@{}lll@{}}
\toprule
Attribut & Type & Rôle \\
\midrule
\texttt{centre\_} & \texttt{Vertex} & Racine de $T$ (centre de l’arbre). \\
\texttt{parent\_} & \texttt{vector<Vertex>} & Parent de $v$ dans $T$ enraciné ; $-1$ pour la racine. \\
\texttt{parent\_edge\_weight\_} & \texttt{vector<Weight>} & Poids de l’arête $(v, \mathtt{parent}[v])$. \\
\texttt{depth\_} & \texttt{vector<int>} & Nombre d’arêtes de la racine à $v$. \\
\texttt{up\_} & \texttt{vector<vector<Vertex>>} & $\mathtt{up}[v][k]$ = $2^k$-ième ancêtre de $v$. \\
\texttt{max\_up\_} & \texttt{vector<vector<Weight>>} & Max des poids sur le chemin $v \to \mathtt{up}[v][k]$. \\
\texttt{max\_path\_table\_} & \texttt{unordered\_map} & Réponses prétraitées pour \texttt{itineraries\_v3}. \\
\bottomrule
\end{tabular}
\end{center}

%=============================================================================
\section*{Bibliographie}
\addcontentsline{toc}{section}{Bibliographie}
%=============================================================================

\begin{enumerate}[label={[\arabic*]}]
  \item \textbf{Polycopié du cours INF421.} Support de cours (poly.pdf), 2025. Document fourni par l’équipe pédagogique.
  \item \textbf{GeeksforGeeks.} \emph{Binary Lifting - Guide for Competitive Programming.} \url{https://www.geeksforgeeks.org/competitive-programming/binary-lifting-guide-for-competitive-programming/}. Consulté en 2025. Référence pour le binary lifting (ancêtres $2^k$, LCA, max sur un chemin dans un arbre).
  \item \textbf{Sujet du projet.} \emph{Matching under constraints} (énoncé du projet INF421 — Most Pleasant Itineraries). Document fourni, 2025.
\end{enumerate}

\end{document}
