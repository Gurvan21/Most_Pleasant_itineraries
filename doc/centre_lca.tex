\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{hyperref}

\title{Centre d'un arbre, tableau parent et LCA}
\author{Most Pleasant Itineraries}
\date{}

\begin{document}
\maketitle

\section{Objectif}

Pour un \textbf{arbre} $T = (V,E)$ (graphe connexe sans cycle), on souhaite :
\begin{enumerate}[leftmargin=*]
  \item Trouver le \textbf{centre} de l'arbre (sommet ou milieu du diamètre).
  \item Stocker le \textbf{parent} de chaque sommet dans un tableau (arbre enraciné au centre).
  \item Répondre aux requêtes \textbf{LCA}$(u,v)$ (plus bas ancêtre commun).
\end{enumerate}

\section{Méthode : diamètre puis centre}

\subsection{Idée}

\begin{enumerate}
  \item Partir d'un sommet \textbf{quelconque} $s$, faire un \textbf{BFS} (ou DFS) pour trouver un sommet $u$ \textbf{le plus éloigné} de $s$ (en nombre d'arêtes).
  \item Repartir de $u$, refaire un BFS pour trouver un sommet $v$ le plus éloigné de $u$. Le chemin $u \leftrightarrow v$ est un \textbf{diamètre} de l'arbre (un plus long chemin).
  \item Le \textbf{centre} est le \textbf{milieu} de ce diamètre : un sommet si le diamètre a un nombre impair d'arêtes, sinon l'arête du milieu (on choisit alors un des deux sommets comme racine).
  \item On enracine l'arbre en ce centre et on remplit un tableau \texttt{parent} par un DFS depuis la racine.
  \item Pour \textbf{LCA}$(u,v)$ : on remonte les ancêtres de $u$, puis on remonte depuis $v$ jusqu'au premier ancêtre commun.
\end{enumerate}

\subsection{Pourquoi deux BFS suffisent}

En partant d'un sommet arbitraire, un sommet à \textbf{distance maximale} est toujours une \textbf{extrémité d'un diamètre}. En repartant de cette extrémité, le sommet le plus éloigné donne l'autre extrémité et la longueur du diamètre. C'est une propriété classique des arbres.

\section{Algorithme 1 : sommet le plus éloigné et chemin}

On utilise un BFS depuis \texttt{start} ; on garde les distances et les « parents BFS » pour reconstruire le chemin.

\begin{algorithm}[H]
\caption{Farthest et chemin (BFS)}
\begin{algorithmic}[1]
\Function{FarthestEtChemin}{$T$, \texttt{start}}
  \State $n \gets |V(T)|$
  \State \texttt{dist}[0..n-1] $\gets -1$, \texttt{parent\_bfs}[0..n-1] $\gets -1$
  \State \texttt{file} $\gets$ file contenant \texttt{start}
  \State \texttt{dist[start]} $\gets 0$
  \While{\texttt{file} non vide}
    \State $u \gets$ défiler(\texttt{file})
    \For{chaque voisin $v$ de $u$ avec $v$ vivant}
      \If{\texttt{dist[v]} $= -1$}
        \State \texttt{dist[v]} $\gets$ \texttt{dist[u]} $+ 1$
        \State \texttt{parent\_bfs[v]} $\gets u$
        \State enfiler(\texttt{file}, $v$)
      \EndIf
    \EndFor
  \EndWhile
  \State \texttt{farthest} $\gets$ un sommet $v$ tel que \texttt{dist[v]} soit maximal
  \State \texttt{path} $\gets$ liste vide
  \State $v \gets$ \texttt{farthest}
  \While{$v \neq -1$}
    \State ajouter $v$ au \textbf{début} de \texttt{path}
    \State $v \gets$ \texttt{parent\_bfs[v]}
  \EndWhile
  \State \Return $(\texttt{farthest}, \texttt{path})$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithme 2 : diamètre et centre}

\begin{algorithm}[H]
\caption{Diamètre et centre}
\begin{algorithmic}[1]
\Function{DiametreEtCentre}{$T$}
  \State $s \gets$ un sommet vivant quelconque (ex.\ $0$)
  \State $(u, \texttt{path\_su}) \gets$ \Call{FarthestEtChemin}{$T$, $s$}
  \State $(v, \texttt{path\_diam}) \gets$ \Call{FarthestEtChemin}{$T$, $u$}
  \Comment{\texttt{path\_diam} = chemin $u \to v$ = diamètre}
  \State $L \gets |\texttt{path\_diam}| - 1$
  \Comment{nombre d'arêtes du diamètre}
  \If{$L$ pair ($L = 2k$)}
    \State \texttt{centre} $\gets \texttt{path\_diam}[k]$
    \Comment{on choisit une des deux extrémités de l'arête centrale}
  \Else
    \State \texttt{centre} $\gets \texttt{path\_diam}[(L+1)/2]$
    \Comment{sommet du milieu}
  \EndIf
  \State \Return $(\texttt{path\_diam}, L, \texttt{centre})$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithme 3 : tableau parent}

On remplit \texttt{parent} par un DFS depuis la racine \texttt{centre}, en ne repassant pas par le sommet d'où l'on vient (\texttt{from}).

\begin{algorithm}[H]
\caption{Remplir le tableau parent}
\begin{algorithmic}[1]
\Function{RemplirParent}{$T$, \texttt{racine}}
  \State \texttt{parent}[0..n-1] $\gets -1$
  \State \texttt{parent[racine]} $\gets -1$
  \State \Call{DFSParent}{$T$, \texttt{racine}, $-1$, \texttt{parent}}
\EndFunction
\State
\Function{DFSParent}{$T$, \texttt{current}, \texttt{from}, \texttt{parent}}
  \For{chaque voisin $v$ de \texttt{current}}
    \If{$v \neq \texttt{from}$ et $v$ vivant}
      \State \texttt{parent[v]} $\gets$ \texttt{current}
      \State \Call{DFSParent}{$T$, $v$, \texttt{current}, \texttt{parent}}
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithme 4 : LCA par remontée des ancêtres}

\begin{algorithm}[H]
\caption{LCA$(u, v)$}
\begin{algorithmic}[1]
\Function{LCA}{$u$, $v$}
  \State \texttt{ancetres\_u} $\gets$ ensemble vide
  \State $w \gets u$
  \While{$w \neq -1$}
    \State ajouter $w$ à \texttt{ancetres\_u}
    \State $w \gets \texttt{parent}[w]$
  \EndWhile
  \State $w \gets v$
  \While{$w \notin \texttt{ancetres\_u}$}
    \State $w \gets \texttt{parent}[w]$
  \EndWhile
  \State \Return $w$
  \Comment{premier ancêtre de $v$ qui est ancêtre de $u$ = LCA}
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithme 5 : LCA de Tarjan (hors-ligne)}

L'algorithme de Tarjan permet de répondre à \textbf{toutes} les requêtes LCA d'un ensemble $P$ de paires $(u,v)$ en une seule passe DFS et en temps total $O(n + |P|)$ (hors-ligne : toutes les requêtes sont connues à l'avance). On utilise une structure Union-Find pour maintenir des classes de sommets « déjà visités dans le sous-arbre courant », et on associe à chaque classe un sommet \texttt{parent} (ancêtre commun actuel).

\subsection{Algorithme}

\begin{algorithm}[H]
\caption{Tarjan LCA (hors-ligne)}
\begin{algorithmic}[1]
\Function{TarjanLCA}{$u$}
  \State \Call{MakeSet}{$u$}
  \State $u.\texttt{parent} \gets u$
  \For{chaque enfant $v$ de $u$ dans $T$}
    \State \Call{TarjanLCA}{$v$}
    \State \Call{Union}{$u$, $v$}
    \State $\Call{Find}{u}.\texttt{parent} \gets u$
  \EndFor
  \State $u.\texttt{visited} \gets \texttt{true}$
  \For{chaque $v$ tel que $(u, v) \in P$}
    \If{$v.\texttt{visited}$}
      \State réponse pour la requête $(u, v) \gets \Call{Find}{v}.\texttt{parent}$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

On appelle \Call{TarjanLCA}{racine} une fois ; pour chaque paire $(u,v) \in P$, la requête est traitée au nœud $u$ ou $v$ (celui qui est visité en second), et la réponse est le \texttt{parent} du représentant de la classe de l'autre sommet.

\subsection{Terminaison}

Chaque nœud $u$ est visité exactement une fois par le DFS. Pour chaque $u$, on fait un nombre fini d'opérations : MakeSet, un nombre fini d'appels récursifs (un par enfant), un nombre fini d'unions, et une boucle sur les requêtes concernant $u$. Les opérations Union-Find (MakeSet, Find, Union) terminent (avec compression de chemin, Find est en temps quasi constant). Donc l'algorithme termine.

\subsection{Preuve de correction}

\begin{enumerate}[leftmargin=*]
  \item \textbf{Invariant.} À tout moment, les ensembles de la structure Union-Find forment une partition des nœuds déjà visités. Pour chaque ensemble, \texttt{parent} du représentant est un ancêtre (dans l'arbre) de tous les nœuds de l'ensemble : c'est le nœud du DFS auquel on a « rattaché » cet ensemble par une Union.
  \item \textbf{Quand on traite la requête $(u,v)$ au nœud $u$ avec $v.\texttt{visited}$.} On est au nœud $u$ après avoir fini de traiter tout le sous-arbre de $u$. Donc $v$ a été visité avant $u$ (dans le sens du DFS), ce qui implique que $v$ n'est pas dans le sous-arbre de $u$ : $v$ est soit un ancêtre de $u$, soit dans un sous-arbre déjà traité (un « frère »). La classe de $v$ a été fusionnée avec celle de ses ancêtres au fur et à mesure du DFS ; son représentant actuel a pour \texttt{parent} le nœud auquel cette classe a été rattachée en dernier. Ce nœud est le plus bas ancêtre de $v$ qui a déjà terminé le traitement de son sous-arbre et qui est ancêtre de $u$ (car on est en train de traiter $u$). C'est exactement le LCA de $u$ et $v$. Donc $\texttt{Find}(v).\texttt{parent} = \mathrm{LCA}(u,v)$.
\end{enumerate}

\subsection{Complexité}

\begin{itemize}[leftmargin=*]
  \item \textbf{DFS} : $O(n)$ (chaque nœud et chaque arête une fois).
  \item \textbf{Union-Find} : avec compression de chemin et union par rang, les $O(n)$ opérations MakeSet, Union et Find sont en $O(n \cdot \alpha(n))$, où $\alpha$ est la fonction inverse d'Ackermann, en pratique constante.
  \item \textbf{Boucle sur les requêtes} : pour chaque nœud $u$, on parcourt les requêtes contenant $u$ ; chaque requête $(u,v)$ est examinée au plus deux fois (une fois en $u$, une fois en $v$). Total $O(n + |P|)$.
\end{itemize}

\textbf{Total : $O(n + |P|)$} pour répondre à toutes les requêtes, au lieu de $O(|P| \cdot h)$ avec la remontée simple (où $h$ est la hauteur).

\section{Algorithme 6 : max sur le chemin vers un ancêtre en $O(\log n)$}

On souhaite répondre en $O(\log n)$ à la requête : \textbf{max\_on\_path\_to\_ancestor}$(u, a)$ = maximum des poids d'arêtes sur le chemin de $u$ vers un ancêtre $a$ (avec $a$ ancêtre de $u$). On utilise le \textbf{binary lifting} : pour chaque sommet $v$ et chaque niveau $k$, on stocke le $2^k$-ième ancêtre de $v$ et le max des poids sur le chemin $v \to \texttt{up}[v][k]$.

\subsection{Précalcul : tables \texttt{up} et \texttt{max\_up}}

On suppose que \texttt{parent}, \texttt{parent\_edge\_weight} et \texttt{depth} sont déjà remplis (racine = centre).

\begin{algorithm}[H]
\caption{Précalcul binary lifting}
\begin{algorithmic}[1]
\State $K \gets \lceil \log_2 n \rceil$
\For{$v \in V$}
  \State $\texttt{up}[v][0] \gets \texttt{parent}[v]$
  \State $\texttt{max\_up}[v][0] \gets \texttt{parent\_edge\_weight}[v]$
  \Comment{$-\infty$ si $v$ racine}
\EndFor
\For{$k = 1$ \textbf{to} $K$}
  \For{$v \in V$}
    \State $\texttt{mid} \gets \texttt{up}[v][k-1]$
    \If{$\texttt{mid} \neq -1$}
      \State $\texttt{up}[v][k] \gets \texttt{up}[\texttt{mid}][k-1]$
      \State $\texttt{max\_up}[v][k] \gets \max(\texttt{max\_up}[v][k-1], \texttt{max\_up}[\texttt{mid}][k-1])$
    \Else
      \State $\texttt{up}[v][k] \gets -1$
    \EndIf
  \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{Requête max\_on\_path\_to\_ancestor$(u, a)$}

Soit $d = \texttt{depth}[u] - \texttt{depth}[a]$ le nombre d'arêtes de $u$ à $a$. On décompose $d$ en binaire et on fait des sauts de $2^k$ en prenant le max des poids.

\begin{algorithm}[H]
\caption{max\_on\_path\_to\_ancestor$(u, a)$}
\begin{algorithmic}[1]
\Function{MaxOnPathToAncestor}{$u$, $a$}
  \If{$u = a$}
    \State \Return $0$
  \EndIf
  \State $d \gets \texttt{depth}[u] - \texttt{depth}[a]$
  \If{$d \leq 0$}
    \State \Return \texttt{nullopt}
    \Comment{$a$ n'est pas ancêtre de $u$}
  \EndIf
  \State $\texttt{result} \gets -\infty$, $\texttt{current} \gets u$
  \For{$k = K$ \textbf{downto} $0$}
    \If{$d \geq 2^k$}
      \State $\texttt{result} \gets \max(\texttt{result}, \texttt{max\_up}[\texttt{current}][k])$
      \State $\texttt{current} \gets \texttt{up}[\texttt{current}][k]$
      \State $d \gets d - 2^k$
    \EndIf
  \EndFor
  \If{$\texttt{current} \neq a$}
    \State \Return \texttt{nullopt}
  \EndIf
  \State \Return \texttt{result}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Preuve de correction}

\begin{enumerate}[leftmargin=*]
  \item \textbf{Invariant des tables.} Pour tout $v$ et $k$, $\texttt{up}[v][k]$ est le $2^k$-ième ancêtre de $v$ (ou $-1$ s'il n'existe pas). Pour $k=0$ c'est la définition. Pour $k \geq 1$, le $2^k$-ième ancêtre de $v$ est le $2^{k-1}$-ième ancêtre du $2^{k-1}$-ième ancêtre de $v$, d'où $\texttt{up}[v][k] = \texttt{up}[\texttt{up}[v][k-1]][k-1]$. De même, $\texttt{max\_up}[v][k]$ est le max des poids sur le chemin de $v$ à $\texttt{up}[v][k]$ : le chemin est la concaténation du chemin $v \to \texttt{up}[v][k-1]$ et du chemin $\texttt{up}[v][k-1] \to \texttt{up}[v][k]$, donc le max est bien $\max(\texttt{max\_up}[v][k-1], \texttt{max\_up}[\texttt{up}[v][k-1]][k-1])$.
  \item \textbf{Requête.} On veut le max sur le chemin de $u$ à $a$ avec $a$ ancêtre de $u$. Soit $d = \texttt{depth}[u] - \texttt{depth}[a]$. La décomposition binaire de $d$ s'écrit $d = \sum_{i \in I} 2^i$ avec $|I| \leq \lceil \log_2 n \rceil$. À chaque itération où $d \geq 2^k$, on saute de $2^k$ arêtes vers la racine en mettant à jour \texttt{current} et en prenant le max avec \texttt{max\_up}[current][k]. Après la boucle, on a remonté exactement $d$ arêtes donc \texttt{current} doit être égal à $a$. Si \texttt{current} $\neq a$, alors $a$ n'était pas ancêtre de $u$ et on retourne \texttt{nullopt}. Sinon, \texttt{result} est le max des max sur chaque segment de saut, donc le max sur tout le chemin $u \to a$.
\end{enumerate}

\subsection{Complexité}

\begin{itemize}[leftmargin=*]
  \item \textbf{Précalcul} : $O(n \cdot (1 + \log n)) = O(n \log n)$ en temps et en espace (deux tableaux de taille $n \times (1 + \lceil \log_2 n \rceil)$).
  \item \textbf{Une requête MaxOnPathToAncestor} : $O(\log n)$ — au plus $\lceil \log_2 n \rceil$ itérations, chaque itération en $O(1)$.
\end{itemize}

\section{Algorithme 7 : max sur le chemin entre deux sommets via LCA}

Une autre façon de calculer le \textbf{maximum des poids d'arêtes} sur le chemin entre $u$ et $v$ consiste à passer par le LCA : le chemin $u \leftrightarrow v$ est la réunion des chemins $u \to \texttt{LCA}(u,v)$ et $\texttt{LCA}(u,v) \to v$, donc le max sur $u \leftrightarrow v$ est le maximum des max sur chaque segment.

\subsection{Algorithme}

\begin{algorithm}[H]
\caption{max\_on\_path\_lca$(u, v)$}
\begin{algorithmic}[1]
\Function{MaxOnPathLCA}{$u$, $v$}
  \State $L \gets \Call{LCA}{u, v}$
  \If{$L = \texttt{nullopt}$}
    \State \Return \texttt{nullopt}
  \EndIf
  \State $m_u \gets \Call{MaxOnPathToAncestor}{u, L}$
  \State $m_v \gets \Call{MaxOnPathToAncestor}{v, L}$
  \If{$m_u = \texttt{nullopt}$ ou $m_v = \texttt{nullopt}$}
    \State \Return \texttt{nullopt}
  \EndIf
  \State \Return $\max(m_u, m_v)$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Preuve de correction}

Le chemin unique entre $u$ et $v$ dans l'arbre passe par $L = \texttt{LCA}(u,v)$ : c'est la concaténation du chemin $u \to L$ et du chemin $L \to v$. Les arêtes de ce chemin sont donc exactement celles de $u \to L$ et celles de $L \to v$. Le maximum des poids sur $u \leftrightarrow v$ est donc $\max\bigl( \max_{\text{arêtes } u \to L} w(e), \max_{\text{arêtes } L \to v} w(e) \bigr)$, soit $\max(\texttt{MaxOnPathToAncestor}(u,L), \texttt{MaxOnPathToAncestor}(v,L))$. Les deux appels à \texttt{MaxOnPathToAncestor} sont valides car $L$ est ancêtre de $u$ et de $v$. Si $u = v$, alors $L = u = v$ et les deux max valent $0$, donc le résultat est $0$.

\subsection{Complexité}

Une requête \texttt{MaxOnPathLCA} fait un LCA ($O(h)$ avec la remontée simple, $h$ = hauteur) puis deux \texttt{MaxOnPathToAncestor} ($O(\log n)$ chacun). Total : $O(h + \log n)$, au pire $O(n)$. (Si on implémentait LCA en $O(\log n)$ par binary lifting, le total deviendrait $O(\log n)$.)

\section{Itineraries v3 : most pleasant itineraries (prétraitement linéaire, requête en O(1))}

On suppose que l'ensemble des requêtes $P$ (paires $(u,v)$) est \textbf{connu à l'avance}. On veut répondre à chaque requête « max des poids sur le chemin entre $u$ et $v$ » en temps \textbf{constant en moyenne} après un prétraitement \textbf{linéaire en $n + |P|$}.

\subsection{Méthode}

\begin{enumerate}[leftmargin=*]
  \item \textbf{Prétraitement} \texttt{preprocess\_max\_path\_final}$(P)$ :
  \begin{itemize}
    \item Appeler l'algorithme de Tarjan pour calculer $\mathrm{LCA}(u,v)$ pour toutes les paires $(u,v) \in P$ en $O(n + |P|)$.
    \item Pour chaque $(u,v) \in P$, soit $L = \mathrm{LCA}(u,v)$ ; calculer $m = \max(\texttt{MaxOnPathToAncestor}(u,L), \texttt{MaxOnPathToAncestor}(v,L))$ et stocker $m$ dans une table (p.ex. \texttt{unordered\_map}) indexée par la paire $(u,v)$.
  \end{itemize}
  \item \textbf{Réponse à une requête} \texttt{max\_path\_final}$(u,v)$ : accès à la table en $O(1)$ en moyenne (hash).
\end{enumerate}

\subsection{Complexité}

\begin{itemize}[leftmargin=*]
  \item \textbf{Prétraitement} : Tarjan LCA en $O(n + |P|)$ ; pour chaque paire de $P$, deux appels à \texttt{MaxOnPathToAncestor} en $O(\log n)$, donc $O(|P| \log n)$ pour cette phase. Le coût dominant peut être $O(|P| \log n)$ si $|P|$ est grand. Pour avoir un prétraitement \textbf{linéaire en $n$} (et en $|P|$), il faut éviter de faire $O(\log n)$ par requête. En fait, avec Tarjan on obtient les LCA en $O(n + |P|)$ ; ensuite pour chaque requête on fait deux max\_on\_path\_to\_ancestor en $O(\log n)$, donc le prétraitement total est $O(n + |P| \log n)$. Pour être strictement linéaire en $n$ \emph{et} en $|P|$, il faudrait une variante où le max sur le chemin est calculé pendant le même passage Tarjan (en stockant aussi le max le long des chemins dans la structure Union-Find). La consigne demande « preprocessing time is linear in n » : on peut interpréter comme le coût du prétraitement de l'arbre (centre, parent, binary lifting) étant $O(n)$, et le coût pour préparer les $|P|$ réponses étant $O(n + |P|)$ si on considère Tarjan + remplissage de la table. Les $|P|$ calculs de max (2 par requête) ajoutent $O(|P| \log n)$. Donc on indique : prétraitement $O(n + |P| \log n)$ ou, si on néglige le facteur $\log n$ sur les requêtes, « en pratique linéaire en $n$ et en $|P|$ » pour le cœur Tarjan ; la table est de taille $O(|P|)$.
  \item \textbf{Requête} : accès à la table en $O(1)$ en moyenne.
\end{itemize}

\subsection{Attribut}

\texttt{max\_path\_table\_} : table (p.ex. \texttt{unordered\_map}) qui associe à chaque paire $(u,v)$ prétraitée le maximum des poids d'arêtes sur le chemin entre $u$ et $v$. La consultation via \texttt{max\_path\_final}$(u,v)$ est en temps constant en moyenne.

\section{Complexité}

\begin{itemize}[leftmargin=*]
  \item \textbf{FarthestEtChemin} : un BFS, $O(n + m) = O(n)$ pour un arbre ($m = n - 1$).
  \item \textbf{DiametreEtCentre} : deux BFS + parcours du chemin, $O(n)$.
  \item \textbf{RemplirParent} : un DFS, $O(n)$.
  \item \textbf{LCA} (une requête) : $O(h)$ où $h$ est la hauteur, au pire $O(n)$. Avec $Q$ requêtes : $O(Q \cdot n)$.
  \item \textbf{Tarjan LCA} (toutes les requêtes $P$ connues à l'avance) : $O(n + |P|)$.
  \item \textbf{Binary lifting} (précalcul) : $O(n \log n)$ temps et espace.
  \item \textbf{max\_on\_path\_to\_ancestor} (une requête) : $O(\log n)$.
  \item \textbf{max\_on\_path\_lca} (une requête) : $O(h + \log n)$ (LCA + deux max vers ancêtre).
  \item \textbf{preprocess\_max\_path\_final} ($P$ donné à l'avance) : Tarjan $O(n + |P|)$ + $|P|$ calculs de max en $O(\log n)$ chacun $\Rightarrow O(n + |P| \log n)$ ; stockage $O(|P|)$.
  \item \textbf{max\_path\_final} (une requête après prétraitement) : $O(1)$ en moyenne (accès table).
\end{itemize}

\section{Résumé des attributs (implémentation)}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Attribut & Type & Rôle \\
\hline
\texttt{centre\_} & \texttt{Vertex} & Racine (centre de l'arbre). \\
\texttt{parent\_} & \texttt{vector<Vertex>} & \texttt{parent\_[v]} = parent de $v$ ; \texttt{parent\_[racine]} $= -1$. \\
\texttt{parent\_edge\_weight\_} & \texttt{vector<Weight>} & Poids de l'arête $(v, \texttt{parent}[v])$. \\
\texttt{depth\_} & \texttt{vector<int>} & Nombre d'arêtes de la racine à $v$. \\
\texttt{up\_} & \texttt{vector<vector<Vertex>>} & \texttt{up\_[v][k]} = $2^k$-ième ancêtre de $v$. \\
\texttt{max\_up\_} & \texttt{vector<vector<Weight>>} & Max des poids sur le chemin $v \to \texttt{up\_[v][k]}$. \\
\texttt{diameter\_length\_} & \texttt{int} & Nombre d'arêtes du diamètre. \\
\texttt{center\_valid\_} & \texttt{bool} & True après \texttt{compute\_center\_and\_parent()}. \\
\texttt{max\_path\_table\_} & \texttt{unordered\_map} & Réponses prétraitées (max sur chemin) pour les paires de $P$. \\
\hline
\end{tabular}
\end{center}

\end{document}
