\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{hyperref}

\title{Centre d'un arbre, tableau parent et LCA}
\author{Most Pleasant Itineraries}
\date{}

\begin{document}
\maketitle

\section{Objectif}

Pour un \textbf{arbre} $T = (V,E)$ (graphe connexe sans cycle), on souhaite :
\begin{enumerate}[leftmargin=*]
  \item Trouver le \textbf{centre} de l'arbre (sommet ou milieu du diamètre).
  \item Stocker le \textbf{parent} de chaque sommet dans un tableau (arbre enraciné au centre).
  \item Répondre aux requêtes \textbf{LCA}$(u,v)$ (plus bas ancêtre commun).
\end{enumerate}

\section{Méthode : diamètre puis centre}

\subsection{Idée}

\begin{enumerate}
  \item Partir d'un sommet \textbf{quelconque} $s$, faire un \textbf{BFS} (ou DFS) pour trouver un sommet $u$ \textbf{le plus éloigné} de $s$ (en nombre d'arêtes).
  \item Repartir de $u$, refaire un BFS pour trouver un sommet $v$ le plus éloigné de $u$. Le chemin $u \leftrightarrow v$ est un \textbf{diamètre} de l'arbre (un plus long chemin).
  \item Le \textbf{centre} est le \textbf{milieu} de ce diamètre : un sommet si le diamètre a un nombre impair d'arêtes, sinon l'arête du milieu (on choisit alors un des deux sommets comme racine).
  \item On enracine l'arbre en ce centre et on remplit un tableau \texttt{parent} par un DFS depuis la racine.
  \item Pour \textbf{LCA}$(u,v)$ : on remonte les ancêtres de $u$, puis on remonte depuis $v$ jusqu'au premier ancêtre commun.
\end{enumerate}

\subsection{Pourquoi deux BFS suffisent}

En partant d'un sommet arbitraire, un sommet à \textbf{distance maximale} est toujours une \textbf{extrémité d'un diamètre}. En repartant de cette extrémité, le sommet le plus éloigné donne l'autre extrémité et la longueur du diamètre. C'est une propriété classique des arbres.

\section{Algorithme 1 : sommet le plus éloigné et chemin}

On utilise un BFS depuis \texttt{start} ; on garde les distances et les « parents BFS » pour reconstruire le chemin.

\begin{algorithm}[H]
\caption{Farthest et chemin (BFS)}
\begin{algorithmic}[1]
\Function{FarthestEtChemin}{$T$, \texttt{start}}
  \State $n \gets |V(T)|$
  \State \texttt{dist}[0..n-1] $\gets -1$, \texttt{parent\_bfs}[0..n-1] $\gets -1$
  \State \texttt{file} $\gets$ file contenant \texttt{start}
  \State \texttt{dist[start]} $\gets 0$
  \While{\texttt{file} non vide}
    \State $u \gets$ défiler(\texttt{file})
    \For{chaque voisin $v$ de $u$ avec $v$ vivant}
      \If{\texttt{dist[v]} $= -1$}
        \State \texttt{dist[v]} $\gets$ \texttt{dist[u]} $+ 1$
        \State \texttt{parent\_bfs[v]} $\gets u$
        \State enfiler(\texttt{file}, $v$)
      \EndIf
    \EndFor
  \EndWhile
  \State \texttt{farthest} $\gets$ un sommet $v$ tel que \texttt{dist[v]} soit maximal
  \State \texttt{path} $\gets$ liste vide
  \State $v \gets$ \texttt{farthest}
  \While{$v \neq -1$}
    \State ajouter $v$ au \textbf{début} de \texttt{path}
    \State $v \gets$ \texttt{parent\_bfs[v]}
  \EndWhile
  \State \Return $(\texttt{farthest}, \texttt{path})$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithme 2 : diamètre et centre}

\begin{algorithm}[H]
\caption{Diamètre et centre}
\begin{algorithmic}[1]
\Function{DiametreEtCentre}{$T$}
  \State $s \gets$ un sommet vivant quelconque (ex.\ $0$)
  \State $(u, \texttt{path\_su}) \gets$ \Call{FarthestEtChemin}{$T$, $s$}
  \State $(v, \texttt{path\_diam}) \gets$ \Call{FarthestEtChemin}{$T$, $u$}
  \Comment{\texttt{path\_diam} = chemin $u \to v$ = diamètre}
  \State $L \gets |\texttt{path\_diam}| - 1$
  \Comment{nombre d'arêtes du diamètre}
  \If{$L$ pair ($L = 2k$)}
    \State \texttt{centre} $\gets \texttt{path\_diam}[k]$
    \Comment{on choisit une des deux extrémités de l'arête centrale}
  \Else
    \State \texttt{centre} $\gets \texttt{path\_diam}[(L+1)/2]$
    \Comment{sommet du milieu}
  \EndIf
  \State \Return $(\texttt{path\_diam}, L, \texttt{centre})$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithme 3 : tableau parent}

On remplit \texttt{parent} par un DFS depuis la racine \texttt{centre}, en ne repassant pas par le sommet d'où l'on vient (\texttt{from}).

\begin{algorithm}[H]
\caption{Remplir le tableau parent}
\begin{algorithmic}[1]
\Function{RemplirParent}{$T$, \texttt{racine}}
  \State \texttt{parent}[0..n-1] $\gets -1$
  \State \texttt{parent[racine]} $\gets -1$
  \State \Call{DFSParent}{$T$, \texttt{racine}, $-1$, \texttt{parent}}
\EndFunction
\State
\Function{DFSParent}{$T$, \texttt{current}, \texttt{from}, \texttt{parent}}
  \For{chaque voisin $v$ de \texttt{current}}
    \If{$v \neq \texttt{from}$ et $v$ vivant}
      \State \texttt{parent[v]} $\gets$ \texttt{current}
      \State \Call{DFSParent}{$T$, $v$, \texttt{current}, \texttt{parent}}
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithme 4 : LCA par remontée des ancêtres}

\begin{algorithm}[H]
\caption{LCA$(u, v)$}
\begin{algorithmic}[1]
\Function{LCA}{$u$, $v$}
  \State \texttt{ancetres\_u} $\gets$ ensemble vide
  \State $w \gets u$
  \While{$w \neq -1$}
    \State ajouter $w$ à \texttt{ancetres\_u}
    \State $w \gets \texttt{parent}[w]$
  \EndWhile
  \State $w \gets v$
  \While{$w \notin \texttt{ancetres\_u}$}
    \State $w \gets \texttt{parent}[w]$
  \EndWhile
  \State \Return $w$
  \Comment{premier ancêtre de $v$ qui est ancêtre de $u$ = LCA}
\EndFunction
\end{algorithmic}
\end{algorithm}

\section{Algorithme 5 : max sur le chemin vers un ancêtre en $O(\log n)$}

On souhaite répondre en $O(\log n)$ à la requête : \textbf{max\_on\_path\_to\_ancestor}$(u, a)$ = maximum des poids d'arêtes sur le chemin de $u$ vers un ancêtre $a$ (avec $a$ ancêtre de $u$). On utilise le \textbf{binary lifting} : pour chaque sommet $v$ et chaque niveau $k$, on stocke le $2^k$-ième ancêtre de $v$ et le max des poids sur le chemin $v \to \texttt{up}[v][k]$.

\subsection{Précalcul : tables \texttt{up} et \texttt{max\_up}}

On suppose que \texttt{parent}, \texttt{parent\_edge\_weight} et \texttt{depth} sont déjà remplis (racine = centre).

\begin{algorithm}[H]
\caption{Précalcul binary lifting}
\begin{algorithmic}[1]
\State $K \gets \lceil \log_2 n \rceil$
\For{$v \in V$}
  \State $\texttt{up}[v][0] \gets \texttt{parent}[v]$
  \State $\texttt{max\_up}[v][0] \gets \texttt{parent\_edge\_weight}[v]$
  \Comment{$-\infty$ si $v$ racine}
\EndFor
\For{$k = 1$ \textbf{to} $K$}
  \For{$v \in V$}
    \State $\texttt{mid} \gets \texttt{up}[v][k-1]$
    \If{$\texttt{mid} \neq -1$}
      \State $\texttt{up}[v][k] \gets \texttt{up}[\texttt{mid}][k-1]$
      \State $\texttt{max\_up}[v][k] \gets \max(\texttt{max\_up}[v][k-1], \texttt{max\_up}[\texttt{mid}][k-1])$
    \Else
      \State $\texttt{up}[v][k] \gets -1$
    \EndIf
  \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{Requête max\_on\_path\_to\_ancestor$(u, a)$}

Soit $d = \texttt{depth}[u] - \texttt{depth}[a]$ le nombre d'arêtes de $u$ à $a$. On décompose $d$ en binaire et on fait des sauts de $2^k$ en prenant le max des poids.

\begin{algorithm}[H]
\caption{max\_on\_path\_to\_ancestor$(u, a)$}
\begin{algorithmic}[1]
\Function{MaxOnPathToAncestor}{$u$, $a$}
  \If{$u = a$}
    \State \Return $0$
  \EndIf
  \State $d \gets \texttt{depth}[u] - \texttt{depth}[a]$
  \If{$d \leq 0$}
    \State \Return \texttt{nullopt}
    \Comment{$a$ n'est pas ancêtre de $u$}
  \EndIf
  \State $\texttt{result} \gets -\infty$, $\texttt{current} \gets u$
  \For{$k = K$ \textbf{downto} $0$}
    \If{$d \geq 2^k$}
      \State $\texttt{result} \gets \max(\texttt{result}, \texttt{max\_up}[\texttt{current}][k])$
      \State $\texttt{current} \gets \texttt{up}[\texttt{current}][k]$
      \State $d \gets d - 2^k$
    \EndIf
  \EndFor
  \If{$\texttt{current} \neq a$}
    \State \Return \texttt{nullopt}
  \EndIf
  \State \Return \texttt{result}
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Preuve de correction}

\begin{enumerate}[leftmargin=*]
  \item \textbf{Invariant des tables.} Pour tout $v$ et $k$, $\texttt{up}[v][k]$ est le $2^k$-ième ancêtre de $v$ (ou $-1$ s'il n'existe pas). Pour $k=0$ c'est la définition. Pour $k \geq 1$, le $2^k$-ième ancêtre de $v$ est le $2^{k-1}$-ième ancêtre du $2^{k-1}$-ième ancêtre de $v$, d'où $\texttt{up}[v][k] = \texttt{up}[\texttt{up}[v][k-1]][k-1]$. De même, $\texttt{max\_up}[v][k]$ est le max des poids sur le chemin de $v$ à $\texttt{up}[v][k]$ : le chemin est la concaténation du chemin $v \to \texttt{up}[v][k-1]$ et du chemin $\texttt{up}[v][k-1] \to \texttt{up}[v][k]$, donc le max est bien $\max(\texttt{max\_up}[v][k-1], \texttt{max\_up}[\texttt{up}[v][k-1]][k-1])$.
  \item \textbf{Requête.} On veut le max sur le chemin de $u$ à $a$ avec $a$ ancêtre de $u$. Soit $d = \texttt{depth}[u] - \texttt{depth}[a]$. La décomposition binaire de $d$ s'écrit $d = \sum_{i \in I} 2^i$ avec $|I| \leq \lceil \log_2 n \rceil$. À chaque itération où $d \geq 2^k$, on saute de $2^k$ arêtes vers la racine en mettant à jour \texttt{current} et en prenant le max avec \texttt{max\_up}[current][k]. Après la boucle, on a remonté exactement $d$ arêtes donc \texttt{current} doit être égal à $a$. Si \texttt{current} $\neq a$, alors $a$ n'était pas ancêtre de $u$ et on retourne \texttt{nullopt}. Sinon, \texttt{result} est le max des max sur chaque segment de saut, donc le max sur tout le chemin $u \to a$.
\end{enumerate}

\subsection{Complexité}

\begin{itemize}[leftmargin=*]
  \item \textbf{Précalcul} : $O(n \cdot (1 + \log n)) = O(n \log n)$ en temps et en espace (deux tableaux de taille $n \times (1 + \lceil \log_2 n \rceil)$).
  \item \textbf{Une requête MaxOnPathToAncestor} : $O(\log n)$ — au plus $\lceil \log_2 n \rceil$ itérations, chaque itération en $O(1)$.
\end{itemize}

\section{Complexité}

\begin{itemize}[leftmargin=*]
  \item \textbf{FarthestEtChemin} : un BFS, $O(n + m) = O(n)$ pour un arbre ($m = n - 1$).
  \item \textbf{DiametreEtCentre} : deux BFS + parcours du chemin, $O(n)$.
  \item \textbf{RemplirParent} : un DFS, $O(n)$.
  \item \textbf{LCA} (une requête) : $O(h)$ où $h$ est la hauteur, au pire $O(n)$. Avec $Q$ requêtes : $O(Q \cdot n)$.
  \item \textbf{Binary lifting} (précalcul) : $O(n \log n)$ temps et espace.
  \item \textbf{max\_on\_path\_to\_ancestor} (une requête) : $O(\log n)$.
\end{itemize}

\section{Résumé des attributs (implémentation)}

\begin{center}
\begin{tabular}{|l|l|l|}
\hline
Attribut & Type & Rôle \\
\hline
\texttt{centre\_} & \texttt{Vertex} & Racine (centre de l'arbre). \\
\texttt{parent\_} & \texttt{vector<Vertex>} & \texttt{parent\_[v]} = parent de $v$ ; \texttt{parent\_[racine]} $= -1$. \\
\texttt{parent\_edge\_weight\_} & \texttt{vector<Weight>} & Poids de l'arête $(v, \texttt{parent}[v])$. \\
\texttt{depth\_} & \texttt{vector<int>} & Nombre d'arêtes de la racine à $v$. \\
\texttt{up\_} & \texttt{vector<vector<Vertex>>} & \texttt{up\_[v][k]} = $2^k$-ième ancêtre de $v$. \\
\texttt{max\_up\_} & \texttt{vector<vector<Weight>>} & Max des poids sur le chemin $v \to \texttt{up\_[v][k]}$. \\
\texttt{diameter\_length\_} & \texttt{int} & Nombre d'arêtes du diamètre. \\
\texttt{center\_valid\_} & \texttt{bool} & True après \texttt{compute\_center\_and\_parent()}. \\
\hline
\end{tabular}
\end{center}

\end{document}
