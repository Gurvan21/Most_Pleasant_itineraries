\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries,
  commentstyle=\itshape,
  numbers=left,
  numberstyle=\tiny,
  frame=single,
  breaklines=true,
  showstringspaces=false,
  language=C++,
  morekeywords={Vertex, Weight, Edge, Graph, std, optional, vector, pair}
}

\title{Documentation de la classe \texttt{Graph}}
\author{Projet Most Pleasant Itineraries}
\date{}

\begin{document}
\maketitle
\tableofcontents
\newpage

%=============================================================================
\section{Introduction}
%=============================================================================

La classe \texttt{Graph} représente un graphe (orienté ou non) par \textbf{liste d'adjacence}. Elle fournit~:
\begin{itemize}[leftmargin=*]
  \item la gestion des sommets et des arêtes (ajout, suppression) ;
  \item les parcours DFS et BFS ;
  \item les algorithmes d'arbre couvrant minimal (Kruskal, Prim) ;
  \item pour un \textbf{arbre}, le calcul du centre, du tableau parent, du LCA et du \emph{max} des poids sur un chemin (\emph{Most Pleasant Itineraries}) en trois versions (v1, v2, v3).
\end{itemize}

Les identifiants des sommets sont des entiers dans $[0, \texttt{num\_vertices()}-1]$. Certains sommets peuvent être \emph{morts} (supprimés) ; les algorithmes ne considèrent que les sommets \emph{vivants} (\texttt{is\_alive}).

\medskip
Fichiers~: \texttt{include/Graph.h}, \texttt{src/Graph.cpp}.

%=============================================================================
\section{Types et structures associées}
%=============================================================================

\subsection{Types alias}
\begin{itemize}[leftmargin=*]
  \item \texttt{Vertex} $=$ \texttt{int} : identifiant d'un sommet.
  \item \texttt{Weight} $=$ \texttt{double} : poids d'une arête.
  \item \texttt{Edge} $=$ \texttt{std::tuple<Vertex, Vertex, Weight>} : arête $(u, v, w)$ (origine, destination, poids). Pour un graphe non orienté, \texttt{get\_edges()} retourne chaque arête une seule fois avec $u \leq v$.
\end{itemize}

\subsection{Structure \texttt{PairHash}}
Utilisée pour stocker des paires $(u,v)$ dans une table de hachage (ex.\ \texttt{max\_path\_table\_}) en les normalisant : la paire $(u,v)$ et la paire $(v,u)$ ont le même hash (ordre canonique $a \leq b$).

%=============================================================================
\section{Représentation interne}
%=============================================================================

\begin{itemize}[leftmargin=*]
  \item \texttt{cont} : vecteur de listes d'adjacence ; \texttt{cont[u]} contient les paires $(v, w)$ pour chaque arête $(u,v)$ de poids $w$. Les arêtes vers des sommets morts peuvent rester en mémoire.
  \item \texttt{alive} : vecteur de booléens (ou \texttt{char}) indiquant si un sommet est vivant.
  \item \texttt{free\_vertices} : pile d'indices de sommets supprimés, réutilisés lors du prochain \texttt{add\_vertex}.
  \item \texttt{directed} : \texttt{true} si le graphe est orienté.
  \item Données dérivées (arbre enraciné au centre) : \texttt{centre\_}, \texttt{parent\_}, \texttt{parent\_edge\_weight\_}, \texttt{depth\_}, \texttt{up\_}, \texttt{max\_up\_}, \texttt{diameter\_length\_}. Valides uniquement après \texttt{compute\_center\_and\_parent()} et invalidées à chaque modification du graphe.
  \item \texttt{max\_path\_table\_} : table de hachage pour les réponses prétraitées de \texttt{itineraries\_v3}.
\end{itemize}

%=============================================================================
\section{Constructeurs}
%=============================================================================

\subsection{\texttt{Graph()}}
Graphe vide, non orienté.

\subsection{\texttt{Graph(adj, directed)}}
Constructeur explicite à partir d'une liste d'adjacence \texttt{adj} (type \texttt{std::vector<std::vector<std::pair<Vertex, Weight>>>}) et du booléen \texttt{directed}. Tous les sommets sont vivants ; centre et table v3 non initialisés.

%=============================================================================
\section{Sommets}
%=============================================================================

\begin{description}[leftmargin=*,style=nextline]
  \item[\texttt{Vertex add\_vertex();}]
    Ajoute un nouveau sommet. Réutilise un indice libéré par \texttt{remove\_vertex} si possible, sinon agrandit le vecteur. Invalide \texttt{center\_valid\_} et \texttt{max\_path\_table\_}. Retourne l'indice du sommet.
  \item[\texttt{void remove\_vertex(Vertex v);}]
    Supprime le sommet \texttt{v} (le marque « mort », vide sa liste d'adjacence, met l'indice dans \texttt{free\_vertices}). Précondition : \texttt{v} valide et vivant. Invalide centre et table v3.
  \item[\texttt{int num\_vertices() const;}]
    Retourne la taille du vecteur de sommets (inclut les morts).
  \item[\texttt{bool is\_alive(Vertex v) const;}]
    Retourne \texttt{true} si \texttt{v} est dans $[0, \texttt{num\_vertices()}-1]$ et marqué vivant. À utiliser dans les algorithmes pour ignorer les sommets supprimés.
\end{description}

%=============================================================================
\section{Arêtes}
%=============================================================================

\begin{description}[leftmargin=*,style=nextline]
  \item[\texttt{void add\_edge(Vertex u, Vertex v, Weight w = 1);}]
    Ajoute l'arête $(u,v)$ de poids \texttt{w}. Si le graphe est non orienté, ajoute aussi $(v,u)$. Préconditions : \texttt{u}, \texttt{v} valides et vivants. Invalide centre et table v3.
  \item[\texttt{void delete\_edge(Vertex u, Vertex v, std::optional<Weight> w = std::nullopt);}]
    Supprime une arête $(u,v)$. Si \texttt{w} est fourni, supprime l'arête dont le poids est (numériquement) égal à \texttt{w} (tolérance pour \texttt{double}). Sinon supprime la première arête vers \texttt{v}. Invalide centre et table v3.
  \item[\texttt{const std::vector<std::pair<Vertex, Weight>>\& neighbors(Vertex u) const;}]
    Retourne une référence constante sur la liste des voisins de \texttt{u} (paires $(v, w)$). Peut contenir des sommets morts : les algorithmes doivent tester \texttt{is\_alive(v)}.
  \item[\texttt{std::vector<Edge> get\_edges() const;}]
    Retourne toutes les arêtes $(u,v,w)$ entre sommets vivants. Graphe non orienté : chaque arête n'apparaît qu'une fois avec $u \leq v$. Utile pour Kruskal.
\end{description}

%=============================================================================
\section{Métadonnées}
%=============================================================================

\begin{description}[leftmargin=*,style=nextline]
  \item[\texttt{bool is\_directed() const;}]
    Indique si le graphe est orienté.
  \item[\texttt{int num\_edges() const;}]
    Nombre d'arêtes (entre sommets vivants). Pour un graphe non orienté, chaque arête est comptée une seule fois.
\end{description}

%=============================================================================
\section{Parcours}
%=============================================================================

\subsection{\texttt{std::vector<Vertex> dfs(Vertex start) const;}}
Parcours en profondeur (DFS) depuis \texttt{start} avec une pile. Retourne l'ordre de découverte des sommets \emph{vivants} atteignables depuis \texttt{start}. Précondition : \texttt{start} valide et vivant. Complexité $O(n + m)$ (sommets et arêtes considérés).

\subsection{\texttt{std::vector<Vertex> bfs(Vertex start) const;}}
Parcours en largeur (BFS) depuis \texttt{start} avec une file. Retourne l'ordre de découverte des sommets vivants. Précondition : \texttt{start} valide et vivant. Complexité $O(n + m)$.

%=============================================================================
\section{Arbre couvrant de poids minimum (MST)}
%=============================================================================

Les deux méthodes retournent un \textbf{nouveau} \texttt{Graph} contenant uniquement les arêtes du MST (même représentation liste d'adjacence). Précondition : graphe \textbf{non orienté}.

\subsection{\texttt{Graph kruskal() const;}}
Algorithme de Kruskal : tri des arêtes par poids croissant, Union-Find pour sélectionner les arêtes du MST. Complexité $O(m \log m)$ (tri dominant).

\subsection{\texttt{Graph prim(Vertex start) const;}}
Algorithme de Prim depuis \texttt{start} : file de priorité (min-heap) sur les arêtes candidates. Complexité $O(m \log m)$ avec une heap standard. Précondition : \texttt{start} valide et vivant.

%=============================================================================
\section{Most Pleasant Itineraries (max sur un chemin)}
%=============================================================================

Pour un \textbf{arbre} (graphe connexe sans cycle), on veut répondre à des requêtes du type : pour deux sommets $u$, $v$, quel est le \textbf{maximum des poids d'arêtes} sur le chemin unique entre $u$ et $v$ ?

\subsection{\texttt{itineraries\_v1(u, v)}}
Implémentation naïve par DFS : on explore le chemin de \texttt{u} vers \texttt{v} en maintenant le max des poids rencontrés. Pas de prétraitement. Complexité \textbf{$O(n)$ par requête}. Retourne \texttt{std::nullopt} si \texttt{u} ou \texttt{v} n'est pas vivant ; retourne $0$ si $u = v$.

\subsection{Prétraitement arbre : centre et parent}
Avant d'utiliser v2 et v3, il faut appeler \texttt{compute\_center\_and\_parent()}. Le graphe doit être \textbf{non orienté} et \textbf{connexe} (en pratique un arbre).

\begin{description}[leftmargin=*,style=nextline]
  \item[\texttt{void compute\_center\_and\_parent();}]
    \begin{enumerate}[nosep]
      \item Deux BFS pour trouver un diamètre (plus long chemin) : BFS depuis un sommet, puis BFS depuis un sommet le plus éloigné.
      \item Le \textbf{centre} est le milieu du diamètre (sommet central ou l'un des deux du milieu d'arête).
      \item Enracinement au centre : remplissage de \texttt{parent\_}, \texttt{parent\_edge\_weight\_} par DFS.
      \item Construction du \textbf{binary lifting} : \texttt{depth\_}, \texttt{up\_} ($2^k$-ième ancêtre), \texttt{max\_up\_} (max sur le chemin vers cet ancêtre).
    \end{enumerate}
    Complexité $O(n \log n)$ (BFS + DFS $O(n)$, binary lifting $O(n \log n)$). Invalide en cas de modification du graphe.
  \item[\texttt{bool has\_center() const;}]
    Retourne \texttt{true} si \texttt{compute\_center\_and\_parent()} a été appelé et n'a pas été invalidé.
  \item[\texttt{Vertex get\_center() const;}]
    Sommet centre (racine). Précondition : \texttt{has\_center()}.
  \item[\texttt{int get\_diameter\_length() const;}]
    Nombre d'arêtes du diamètre. Précondition : \texttt{has\_center()}.
  \item[\texttt{Vertex get\_parent(Vertex v) const;}]
    Parent de \texttt{v} dans l'arbre enraciné au centre ; $-1$ pour la racine. Précondition : \texttt{has\_center()}.
\end{description}

\subsection{LCA (Plus bas ancêtre commun)}
\begin{description}[leftmargin=*,style=nextline]
  \item[\texttt{std::optional<Vertex> lca(Vertex u, Vertex v) const;}]
    Plus bas ancêtre commun de \texttt{u} et \texttt{v}. Implémentation par \textbf{binary lifting} avec la table \texttt{up\_} : mise à la même profondeur puis remontée par paliers. Complexité \textbf{$O(\log n)$}. Précondition : \texttt{has\_center()}, \texttt{u} et \texttt{v} vivants.
  \item[\texttt{std::vector<std::optional<Vertex>> tarjan\_lca(queries) const;}]
    LCA \emph{hors-ligne} pour une liste de paires \texttt{queries}. Algorithme de Tarjan (DFS + Union-Find). Complexité $O(n + |P|)$. Retourne les LCA dans le même ordre que les paires. Précondition : \texttt{has\_center()}.
\end{description}

\subsection{\texttt{max\_on\_path\_to\_ancestor(u, a)}}
Retourne le maximum des poids d'arêtes sur le chemin de \texttt{u} vers l'ancêtre \texttt{a} (avec binary lifting \texttt{max\_up\_}). Précondition : \texttt{a} ancêtre de \texttt{u}, \texttt{has\_center()}. Complexité \textbf{$O(\log n)$}.

\subsection{\texttt{itineraries\_v2(u, v)}}
\begin{enumerate}[nosep]
  \item Calcul de $L = \texttt{lca}(u, v)$ (binary lifting, $O(\log n)$).
  \item $\mu = \texttt{max\_on\_path\_to\_ancestor}(u, L)$, $\nu = \texttt{max\_on\_path\_to\_ancestor}(v, L)$.
  \item Retourne $\max(\mu, \nu)$.
\end{enumerate}
Précondition : \texttt{has\_center()}. Complexité \textbf{$O(\log n)$ par requête} après le prétraitement $O(n)$.

\subsection{\texttt{preprocess\_itineraries\_v3(queries)} et \texttt{itineraries\_v3(u, v)}}
\begin{description}[leftmargin=*,style=nextline]
  \item[\texttt{void preprocess\_itineraries\_v3(const std::vector<std::pair<Vertex, Vertex>>\& queries);}]
    Précalcule les réponses pour toutes les paires dans \texttt{queries} : Tarjan LCA puis pour chaque paire $(u,v)$ le max sur le chemin (via \texttt{max\_on\_path\_to\_ancestor}). Stocke les résultats dans \texttt{max\_path\_table\_}. À appeler une fois quand l'ensemble des requêtes est connu. Précondition : \texttt{has\_center()}. Complexité $O(n + |P|)$.
  \item[\texttt{std::optional<Weight> itineraries\_v3(Vertex u, Vertex v) const;}]
    Lookup dans \texttt{max\_path\_table\_} (paire normalisée $(min(u,v), max(u,v))$). Complexité \textbf{$O(1)$ en moyenne}. Retourne \texttt{std::nullopt} si la paire n'a pas été prétraitée.
\end{description}

%=============================================================================
\section{Affichage et export}
%=============================================================================

\begin{description}[leftmargin=*,style=nextline]
  \item[\texttt{void print\_graph(std::ostream\& out) const;}]
    Affiche la liste d'adjacence (sommets vivants uniquement) : pour chaque sommet, la liste des voisins avec poids.
  \item[\texttt{void print\_summary(std::ostream\& out) const;}]
    Affiche un résumé : nombre de sommets vivants, nombre d'arêtes, orienté ou non.
  \item[\texttt{void write\_dot(std::ostream\& out, const std::string\& name = "G") const;}]
    Export au format DOT (Graphviz). À compiler avec \texttt{dot -Tpng fichier.dot -o out.png} ou à ouvrir sur graphviz.org.
  \item[\texttt{void write\_dot\_file(const std::string\& path, ...);}]
    Écrit le DOT dans un fichier.
  \item[\texttt{void write\_html\_file(const std::string\& path, ...);}]
    Génère une page HTML avec dessin du graphe (SVG, layout circulaire). Peut être désactivée dans l'implémentation.
  \item[\texttt{operator<<(std::ostream\&, const Graph\&)}]
    Équivalent à \texttt{print\_graph}.
\end{description}

%=============================================================================
\section{Méthode privée}
%=============================================================================

\begin{description}[leftmargin=*,style=nextline]
  \item[\texttt{void build\_binary\_lifting(int n);}]
    Appelée par \texttt{compute\_center\_and\_parent()}. Remplit \texttt{depth\_}, \texttt{up\_} (ancêtres à puissances de 2), \texttt{max\_up\_} (max sur les chemins correspondants). Complexité $O(n \log n)$.
\end{description}

%=============================================================================
\section{Tableau récapitulatif des complexités}
%=============================================================================

\begin{center}
\begin{tabular}{@{}lll@{}}
\toprule
Méthode & Complexité & Remarque \\
\midrule
\texttt{add\_vertex}, \texttt{remove\_vertex} & $O(1)$ amorti & \\
\texttt{add\_edge}, \texttt{delete\_edge} & $O(\deg(u))$ & invalide centre / v3 \\
\texttt{neighbors}, \texttt{num\_vertices}, \texttt{is\_alive} & $O(1)$ & \\
\texttt{get\_edges}, \texttt{num\_edges} & $O(n+m)$ & \\
\texttt{dfs}, \texttt{bfs} & $O(n+m)$ & \\
\texttt{kruskal} & $O(m \log m)$ & tri des arêtes \\
\texttt{prim} & $O(m \log m)$ & file de priorité \\
\texttt{itineraries\_v1(u,v)} & $O(n)$ & par requête, pas de prétraitement \\
\texttt{compute\_center\_and\_parent} & $O(n \log n)$ & BFS + DFS + binary lifting \\
\texttt{lca(u,v)} & $O(\log n)$ & binary lifting \\
\texttt{tarjan\_lca(queries)} & $O(n + |P|)$ & hors-ligne \\
\texttt{max\_on\_path\_to\_ancestor(u,a)} & $O(\log n)$ & \\
\texttt{itineraries\_v2(u,v)} & $O(\log n)$ & après prétraitement \\
\texttt{preprocess\_itineraries\_v3(queries)} & $O(n + |P|)$ & une fois \\
\texttt{itineraries\_v3(u,v)} & $O(1)$ moy. & après prétraitement \\
\bottomrule
\end{tabular}
\end{center}

\medskip
$n$ = nombre de sommets (vivants), $m$ = nombre d'arêtes, $|P|$ = nombre de requêtes (paires).

%=============================================================================
\section{Invalidation}
%=============================================================================

Les opérations suivantes mettent \texttt{center\_valid\_} à \texttt{false} et vident \texttt{max\_path\_table\_}~: \texttt{add\_edge}, \texttt{delete\_edge}, \texttt{add\_vertex}, \texttt{remove\_vertex}. Il faut rappeler \texttt{compute\_center\_and\_parent()} avant d'utiliser à nouveau \texttt{itineraries\_v2}, \texttt{lca}, \texttt{get\_parent}, etc., et \texttt{preprocess\_itineraries\_v3(queries)} avant \texttt{itineraries\_v3}.

\end{document}
